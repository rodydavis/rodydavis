---
import type { MarkdownInstance } from "astro";
import path from "path";
import TagChip from "./TagChip";

interface Note {
  article: MarkdownInstance<Record<string, any>>;
  tags: string[];
  slug: string;
}

export function getTagsFromSource(
  source: MarkdownInstance<Record<string, any>>
): string[] {
  const content = source.rawContent();
  const tagList: string[] = [];
  // Tags with # in front and has space before # and after
  // Tag can contain / and - but not at the start
  const matches = content.match(/(?<=\s)#([a-zA-Z0-9-\/]+)(?=\s)/g);
  if (matches) {
    for (const match of matches) {
      // Check if hex color
      if (match.length === 7 && match[0] === "#") {
        const parts = match.split("#");
        if (parts.length === 2) {
          const hex = parts[1];
          if (hex.match(/^[0-9A-F]+$/i)) {
            continue;
          }
        }
      }
      if (!tagList.includes(match)) {
        // Remove # from tag
        const tag = match.replace("#", "");
        tagList.push(tag);
      }
    }
  }
  // Add tokens from frontmatter
  const frontmatter = source.frontmatter.tags || [];
  for (const tag of frontmatter) {
    if (!tagList.includes(tag)) {
      tagList.push(tag);
    }
  }
  return tagList;
}

export async function getTags() {
  const notesPath = path.join(process.cwd(), "notes");
  const targets = await Astro.glob("../../notes/**/*.md");
  const tagMap = new Map<string, Note[]>();
  for (const target of targets) {
    const tags = getTagsFromSource(target);
    for (const tag of tags) {
      if (!tagMap.has(tag)) {
        tagMap.set(tag, []);
      }
      const list = tagMap.get(tag)!;
      if (list) {
        const filePath = target.file || "";
        let slug = filePath.replace(notesPath, "").replace(/\.md$/, "");
        slug = slug.replace(/^\//, "");
        const noteTags = getTagsFromSource(target);
        list.push({
          article: target,
          tags: noteTags,
          slug,
        });
      }
      tagMap.set(tag, list);
    }
  }
  const results = [];
  const tagList = Array.from(tagMap.keys()).sort();
  for (const tag of tagList) {
    const list = tagMap.get(tag)!;
    results.push({ params: { tag }, props: { list, tag } });
  }
  // Sort alphabetically
  results.sort((a, b) => {
    if (a.props.tag < b.props.tag) {
      return -1;
    }
    if (a.props.tag > b.props.tag) {
      return 1;
    }
    return 0;
  });
  return results;
}

const tags = await getTags();
const icons = await fetch(
  "https://gist.githubusercontent.com/AmirOfir/daee915574b1ba0d877da90777dc2181/raw/c27590c91ad5494ca3e8861c02eedcd537e4e1ff/material-icons-list-json.json"
)
  .then((res) => res.json())
  .then((json) => json.categories);

function getMaterialIconForTag(tag: string): string {
  for (const category of icons) {
    for (const icon of category.icons) {
      if (icon.name === tag) {
        return icon.name;
      }
    }
  }
  return "info_outlined";
}
---

<style>
  h2 {
    color: inherit;
  }
  ul {
    list-style: none;
    padding: 0;
  }
  li {
    margin: 0;
  }
  a {
    color: inherit;
    text-decoration: none;
  }
  a:hover label {
    text-decoration: underline;
  }
</style>

<div
  class="tags"
  style={{
    display: "flex",
    flexWrap: "wrap",
    gap: "0.5rem",
  }}
>
  {
    tags.map((tag) => {
      const name = tag.props.tag;
      const icon = getMaterialIconForTag(name);
      return <TagChip tag={name} icon={icon} active={false} client:idle />;
    })
  }
</div>
