---
title: Flutter Infinite Canvas
description: >
  Learn how to build an infinite, multi-touch canvas in Flutter using
  InteractiveViewer and CustomMultiChildLayout for a flexible and interactive
  user experience.
date: '2025-01-19 05:33:00.331Z'
draft: false
tags:
  - Dart
  - Flutter
  - UI-UX
summary: >-
  Create an infinite canvas in Flutter using `InteractiveViewer` and
  `CustomMultiChildLayout` to display multiple scrollable scaffolds.
embedding: >-
  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
related:
  - flutter-multi-touch-canvas.md
  - snippets/flutter-master-detail-view.md
  - snippets/flutter-stream-widget.md
  - deep-linking-flutter-web.md
  - snippets/lightweight-flutter-animations.md
---

Overview 
---------

The following is an example of how to build an infinite canvas with [InteractiveViewer](https://api.flutter.dev/flutter/widgets/InteractiveViewer-class.html) and [CustomMultiChildLayout](https://api.flutter.dev/flutter/widgets/CustomMultiChildLayout-class.html).

Blog post: [Create a multi touch canvas in Flutter](https://rodydavis.com/posts/flutter-multi-touch-canvas)

```dart
import 'package:flutter/material.dart';
import 'package:vector_math/vector_math_64.dart' hide Colors;

void main() {
  final controller = WidgetCanvasController([
    WidgetCanvasChild(
      key: UniqueKey(),
      offset: Offset.zero,
      size: const Size(400, 800),
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Scaffold 1'),
        ),
        body: const Placeholder(),
      ),
    ),
    WidgetCanvasChild(
      key: UniqueKey(),
      offset: const Offset(200, 200),
      size: const Size(400, 800),
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Scaffold 2'),
        ),
        body: const Placeholder(),
      ),
    ),
  ]);
  runApp(MaterialApp(home: WidgetCanvas(controller: controller)));
}

class WidgetCanvas extends StatefulWidget {
  const WidgetCanvas({super.key, required this.controller});

  final WidgetCanvasController controller;

  @override
  State<WidgetCanvas> createState() => WidgetCanvasState();
}

class WidgetCanvasState extends State<WidgetCanvas> {
  @override
  void initState() {
    super.initState();
    controller.addListener(onUpdate);
  }

  @override
  void dispose() {
    controller.removeListener(onUpdate);
    super.dispose();
  }

  void onUpdate() {
    if (mounted) setState(() {});
  }

  static const Size _gridSize = Size.square(50);
  WidgetCanvasController get controller => widget.controller;

  Rect axisAlignedBoundingBox(Quad quad) {
    double xMin = quad.point0.x;
    double xMax = quad.point0.x;
    double yMin = quad.point0.y;
    double yMax = quad.point0.y;
    for (final Vector3 point in <Vector3>[
      quad.point1,
      quad.point2,
      quad.point3,
    ]) {
      if (point.x < xMin) {
        xMin = point.x;
      } else if (point.x > xMax) {
        xMax = point.x;
      }

      if (point.y < yMin) {
        yMin = point.y;
      } else if (point.y > yMax) {
        yMax = point.y;
      }
    }

    return Rect.fromLTRB(xMin, yMin, xMax, yMax);
  }

  @override
  Widget build(BuildContext context) {
    const inset = 2.0;
    return Listener(
      onPointerDown: (details) {
        controller.mouseDown = true;
        controller.checkSelection(details.localPosition);
      },
      onPointerUp: (details) {
        controller.mouseDown = false;
      },
      onPointerCancel: (details) {
        controller.mouseDown = false;
      },
      onPointerMove: (details) {},
      child: LayoutBuilder(
        builder: (context, constraints) => InteractiveViewer.builder(
          transformationController: controller.transform,
          panEnabled: controller.canvasMoveEnabled,
          scaleEnabled: controller.canvasMoveEnabled,
          onInteractionStart: (details) {
            controller.mousePosition = details.focalPoint;
          },
          onInteractionUpdate: (details) {
            if (!controller.mouseDown) {
              controller.scale = details.scale;
            } else {
              controller.moveSelection(details.focalPoint);
            }
            controller.mousePosition = details.focalPoint;
          },
          onInteractionEnd: (details) {},
          minScale: 0.4,
          maxScale: 4,
          boundaryMargin: const EdgeInsets.all(double.infinity),
          builder: (context, viewport) {
            return SizedBox(
              width: 1,
              height: 1,
              child: Stack(
                clipBehavior: Clip.none,
                children: [
                  Positioned.fill(
                    child: GridBackgroundBuilder(
                      cellWidth: _gridSize.width,
                      cellHeight: _gridSize.height,
                      viewport: axisAlignedBoundingBox(viewport),
                    ),
                  ),
                  Positioned.fill(
                    child: CustomMultiChildLayout(
                      delegate: WidgetCanvasDelegate(controller),
                      children: controller.children.map((e) {
                        return LayoutId(
                            id: e,
                            child: Stack(
                              clipBehavior: Clip.none,
                              children: [
                                Positioned.fill(
                                  child: Material(
                                    elevation: 4,
                                    child: SizedBox.fromSize(
                                      size: e.size,
                                      child: e.child,
                                    ),
                                  ),
                                ),
                                if (controller.isSelected(e.key!))
                                  Positioned.fill(
                                    top: -inset,
                                    left: -inset,
                                    right: -inset,
                                    bottom: -inset,
                                    child: Container(
                                      decoration: BoxDecoration(
                                        border: Border.all(
                                          color: Colors.blue,
                                          width: 1,
                                        ),
                                      ),
                                    ),
                                  ),
                              ],
                            ));
                      }).toList(),
                    ),
                  ),
                ],
              ),
            );
          },
        ),
      ),
    );
  }
}

class GridBackgroundBuilder extends StatelessWidget {
  const GridBackgroundBuilder({
    super.key,
    required this.cellWidth,
    required this.cellHeight,
    required this.viewport,
  });

  final double cellWidth;
  final double cellHeight;
  final Rect viewport;

  @override
  Widget build(BuildContext context) {
    final int firstRow = (viewport.top / cellHeight).floor();
    final int lastRow = (viewport.bottom / cellHeight).ceil();
    final int firstCol = (viewport.left / cellWidth).floor();
    final int lastCol = (viewport.right / cellWidth).ceil();

    return Stack(
      clipBehavior: Clip.none,
      children: <Widget>[
        for (int row = firstRow; row < lastRow; row++)
          for (int col = firstCol; col < lastCol; col++)
            Positioned(
              left: col * cellWidth,
              top: row * cellHeight,
              child: Container(
                height: cellHeight,
                width: cellWidth,
                decoration: BoxDecoration(
                  border: Border.all(
                    color: Colors.grey.withOpacity(0.1),
                    width: 1,
                  ),
                ),
              ),
            ),
      ],
    );
  }
}

class WidgetCanvasDelegate extends MultiChildLayoutDelegate {
  WidgetCanvasDelegate(this.controller);
  final WidgetCanvasController controller;
  List<WidgetCanvasChild> get children => controller.children;

  Size backgroundSize = const Size(100000, 100000);
  late Offset backgroundOffset = Offset(
    -backgroundSize.width / 2,
    -backgroundSize.height / 2,
  );

  @override
  void performLayout(Size size) {
    // Then draw the screens.
    for (final widget in children) {
      layoutChild(widget, BoxConstraints.tight(widget.size));
      positionChild(widget, widget.offset);
    }
  }

  @override
  bool shouldRelayout(WidgetCanvasDelegate oldDelegate) => true;
}

class WidgetCanvasChild extends StatelessWidget {
  const WidgetCanvasChild({
    required Key key,
    required this.size,
    required this.offset,
    required this.child,
  }) : super(key: key);

  final Size size;
  final Offset offset;
  final Widget child;

  Rect get rect => offset & size;

  WidgetCanvasChild copyWith({
    Size? size,
    Offset? offset,
    Widget? child,
  }) {
    return WidgetCanvasChild(
      key: key!,
      size: size ?? this.size,
      offset: offset ?? this.offset,
      child: child ?? this.child,
    );
  }

  @override
  Widget build(BuildContext context) {
    return child;
  }
}

class WidgetCanvasController extends ChangeNotifier {
  WidgetCanvasController(this.children);

  final List<WidgetCanvasChild> children;
  final Set<Key> _selected = {};
  late final transform = TransformationController();
  Matrix4 get matrix => transform.value;
  double scale = 1;
  Offset mousePosition = Offset.zero;

  bool _mouseDown = false;
  bool get mouseDown => _mouseDown;
  set mouseDown(bool value) {
    _mouseDown = value;
    notifyListeners();
  }

  bool isSelected(Key key) => _selected.contains(key);

  bool get hasSelection => _selected.isNotEmpty;

  bool get canvasMoveEnabled => !mouseDown;

  Offset toLocal(Offset global) {
    return transform.toScene(global);
  }

  void checkSelection(Offset localPosition) {
    final offset = toLocal(localPosition);
    final selection = <Key>[];
    for (final child in children) {
      final rect = child.rect;
      if (rect.contains(offset)) {
        selection.add(child.key!);
      }
    }
    if (selection.isNotEmpty) {
      setSelection({selection.last});
    } else {
      deselectAll();
    }
  }

  void moveSelection(Offset position) {
    final delta = toLocal(position) - toLocal(mousePosition);
    for (final key in _selected) {
      final index = children.indexWhere((e) => e.key == key);
      if (index == -1) continue;
      final current = children[index];
      children[index] = current.copyWith(
        offset: current.offset + delta,
      );
    }
    mousePosition = position;
    notifyListeners();
  }

  void select(Key key) {
    _selected.add(key);
    notifyListeners();
  }

  void setSelection(Set<Key> keys) {
    _selected.clear();
    _selected.addAll(keys);
    notifyListeners();
  }

  void deselect(Key key) {
    _selected.remove(key);
    notifyListeners();
  }

  void deselectAll() {
    _selected.clear();
    notifyListeners();
  }

  void add(WidgetCanvasChild child) {
    children.add(child);
    notifyListeners();
  }

  void remove(Key key) {
    children.removeWhere((e) => e.key == key);
    notifyListeners();
  }
}
```

Demo
----
