
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <base href="/">
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Host your Flutter Project as a REST API</title>
      <link rel="stylesheet" type="text/css" href="/index.css" />
      <link rel="stylesheet" type="text/css" href="/article.css" />
      <link
        href="https://fonts.googleapis.com/css?family=Material+Icons&display=block"
        rel="stylesheet"
      />
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css">
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
    </head>
    <body>
      <nav-wrapper title="Host your Flutter Project as a REST API">
        <article>
         <h2 id="host-your-flutter-project-as-a-rest-api">Host your Flutter Project as a REST API</h2>
<p>After you build your flutter project you may want to reuse the models and business logic from your lib folder. I will show you how to go about setting up the project to have iOS, Android, Web, Windows, MacOS, Linux and a REST API interface with one project. The REST API can also be deploy to Google Cloud Run for Dart everywhere.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*_pGj3DixmBImxcAl_HWWdA.gif" alt="" /></p>
<blockquote>
  <p>One Codebase for Client and Sever.</p>
</blockquote>
<p>This will allow you to expose your Dart models as a REST API and run your business logic from your lib folder while the application runs the models as they are. <a href="https://github.com/AppleEducate/shared_dart" rel="noopener noreferrer" target="_blank">Here</a> is the final project.</p>
<h3 id="setting-up">Setting Up</h3>
<p>As with any Flutter project I am going to assume that you already have <a href="https://flutter.dev/" rel="noopener noreferrer" target="_blank">Flutter</a> installed on your machine and that you can create a project. This is a intermediate level difficulty so read on if you are up to the challenge. You will also need to know the basics of <a href="https://www.docker.com/" rel="noopener noreferrer" target="_blank">Docker</a>.</p>
<h3 id="why-one-project">Why one project?</h3>
<p>It may not be obvious but when building complex applications you will at some point have a server and an application that calls that server. <a href="https://firebase.google.com/" rel="noopener noreferrer" target="_blank">Firebase</a> is an excellent option for doing this and I use it in almost all my projects. <a href="https://firebase.google.com/products/functions/" rel="noopener noreferrer" target="_blank">Firebase Functions</a> are really powerful but you are limited by Javascript or Typescript. What if you could use the same packages that you are using in the Flutter project, or better yet what if they both used the same?</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*1xVIzjzgJnmuWTJoaG3kAQ.gif" alt="" /></p>
<p>When you have a server project and a client project that communicate over a rest api or client sdk like Firebase then you will run into the problem that the server has models of objects stored and the client has models of the objects that are stored. This can lead to a serious mismatch when it changed without you knowing. GraphQL helps a lot with this since you define the model that you recieve. This approach allows your business logic to be always up to date for both the client and server.</p>
<h3 id="client-setup">Client Setup</h3>
<p>The first step is to just build your application. The only difference that we will make is keeping the UI and business logic separate. When starting out with Flutter it can be very easy to throw all the logic into the screen and calling setState when the data changes. Even the application when creating a new Flutter project does this. That's why <a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/options" rel="noopener noreferrer" target="_blank">choosing a state management solution </a>is so important.</p>
<iframe src="https://medium.com/media/64311732193c2dd39b2cdbc42965b538" frameborder=0></iframe>
<p>To make things clean and concise we will make 2 folders in our lib folder.</p>
<ul>
<li><p>ui for all Flutter Widgets and Screens</p></li>
<li><p>src for all business logic, classes, models and utility functions</p></li>
</ul>
<p>This will leave us with main.dart being only the entry point into our client application.</p>
<pre><code>import 'package:flutter/material.dart';

import 'plugins/desktop/desktop.dart';
import 'ui/home/screen.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  [@override](http://twitter.com/override)
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData.light(),
      darkTheme: ThemeData.dark(),
      home: HomeScreen(),
    );
  }
}</code></pre>
<p>Let’s Start by making a tab bar for the 2 screens. Create a file in the folder ui/home/screen.dart and add the following:</p>
<pre><code>import 'package:flutter/material.dart';

import '../counter/screen.dart';
import '../todo/screen.dart';

class HomeScreen extends StatefulWidget {
  [@override](http://twitter.com/override)
  _HomeScreenState createState() =&gt; _HomeScreenState();
}

class _HomeScreenState extends State&lt;HomeScreen&gt; {
  int _currentIndex = 0;

[@override](http://twitter.com/override)
  Widget build(BuildContext context) {
    return Scaffold(
      body: IndexedStack(
        index: _currentIndex,
        children: &lt;Widget&gt;[
          CounterScreen(),
          TodosScreen(),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (val) {
          if (mounted)
            setState(() {
              _currentIndex = val;
            });
        },
        type: BottomNavigationBarType.fixed,
        items: [
          BottomNavigationBarItem(
            icon: Icon(Icons.add),
            title: Text('Counter'),
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.list),
            title: Text('Todos'),
          ),
        ],
      ),
    );
  }
}</code></pre>
<p>This is just a basic screen and should look very normal.</p>
<h4 id="counter-example">Counter Example</h4>
<p><img src="https://cdn-images-1.medium.com/max/2336/1*qFZepZBtk0RhEojjGsI85g.png" alt="" /></p>
<p>Now create a file ui/counter/screen.dart and add the following:</p>
<pre><code>import 'package:flutter/material.dart';
import 'package:shared_dart/src/models/counter.dart';

class CounterScreen extends StatefulWidget {
  [@override](http://twitter.com/override)
  _CounterScreenState createState() =&gt; _CounterScreenState();
}

class _CounterScreenState extends State&lt;CounterScreen&gt; {
  CounterModel _counterModel = CounterModel();

void _incrementCounter() {
    setState(() {
      // This call to setState tells the Flutter framework that something has
      // changed in this State, which causes it to rerun the build method below
      // so that the display can reflect the updated values. If we changed
      // _counter without calling setState(), then the build method would not be
      // called again, and so nothing would appear to happen.
      _counterModel.add();
    });
  }

[@override](http://twitter.com/override)
  Widget build(BuildContext context) {
    // This method is rerun every time setState is called, for instance as done
    // by the _incrementCounter method above.
    //
    // The Flutter framework has been optimized to make rerunning build methods
    // fast, so that you can just rebuild anything that needs updating rather
    // than having to individually change instances of widgets.
    return Scaffold(
      appBar: AppBar(
        // Here we take the value from the MyCounterPage object that was created by
        // the App.build method, and use it to set our appbar title.
        title: Text('Counter Screen'),
      ),
      body: Center(
        // Center is a layout widget. It takes a single child and positions it
        // in the middle of the parent.
        child: Column(
          // Column is also a layout widget. It takes a list of children and
          // arranges them vertically. By default, it sizes itself to fit its
          // children horizontally, and tries to be as tall as its parent.
          //
          // Invoke "debug painting" (press "p" in the console, choose the
          // "Toggle Debug Paint" action from the Flutter Inspector in Android
          // Studio, or the "Toggle Debug Paint" command in Visual Studio Code)
          // to see the wireframe for each widget.
          //
          // Column has various properties to control how it sizes itself and
          // how it positions its children. Here we use mainAxisAlignment to
          // center the children vertically; the main axis here is the vertical
          // axis because Columns are vertical (the cross axis would be
          // horizontal).
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            Text(
              'You have pushed the button this many times:',
            ),
            Text(
              '${_counterModel.count}',
              style: Theme.of(context).textTheme.display1,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ), // This trailing comma makes auto-formatting nicer for build methods.
    );
  }
}</code></pre>
<p>This is the default counter app you get when you create a Flutter application but with one change, it uses <code>CounterModel</code> to hold the logic.</p>
<p>Create the counter model at src/models/counter.dart and add the following:</p>
<pre><code>class CounterModel {
  CounterModel();

int _count = 0;

int get count =&gt; _count;

void add() =&gt; _count++;

void subtract() =&gt; _count--;

void set(int val) =&gt; _count = val;
}</code></pre>
<p>As you can see it is really easy to expose only what we want to while still having complete flexibility. You could use provider here if you choose, or even bloc and/or streams.</p>
<h4 id="todo-example">Todo Example</h4>
<p><img src="https://cdn-images-1.medium.com/max/2336/1*47x4TDkyWCo8-qMCfYaeng.png" alt="" /></p>
<p>Lets create a file at ui/todos/screen.dart and add the following:</p>
<pre><code>import 'package:flutter/material.dart';

import '../../src/classes/todo.dart';
import '../../src/models/todos.dart';

class TodosScreen extends StatefulWidget {
  [@override](http://twitter.com/override)
  _TodosScreenState createState() =&gt; _TodosScreenState();
}

class _TodosScreenState extends State&lt;TodosScreen&gt; {
  final _model = TodosModel();
  List&lt;ToDo&gt; _todos;

[@override](http://twitter.com/override)
  void initState() {
    _model.getList().then((val) {
      if (mounted)
        setState(() {
          _todos = val;
        });
    });
    super.initState();
  }

[@override](http://twitter.com/override)
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Todos Screen'),
      ),
      body: Builder(
        builder: (_) {
          if (_todos != null) {
            return ListView.builder(
              itemCount: _todos.length,
              itemBuilder: (context, index) {
                final _item = _todos[index];
                return ListTile(
                  title: Text(_item.title),
                  subtitle: Text(_item.completed ? 'Completed' : 'Pending'),
                );
              },
            );
          }
          return Center(
            child: CircularProgressIndicator(),
          );
        },
      ),
    );
  }
}</code></pre>
<p>You will see that we have the logic in TodosModel and uses the class ToDo for toJson and fromJson.</p>
<p>Create a file at the location src/classes/todo.dart and add the following:</p>
<pre><code>// To parse this JSON data, do
//
//     final toDo = toDoFromJson(jsonString);

import 'dart:convert';

List&lt;ToDo&gt; toDoFromJson(String str) =&gt; List&lt;ToDo&gt;.from(json.decode(str).map((x) =&gt; ToDo.fromJson(x)));

String toDoToJson(List&lt;ToDo&gt; data) =&gt; json.encode(List&lt;dynamic&gt;.from(data.map((x) =&gt; x.toJson())));

class ToDo {
    int userId;
    int id;
    String title;
    bool completed;

ToDo({
        this.userId,
        this.id,
        this.title,
        this.completed,
    });

factory ToDo.fromJson(Map&lt;String, dynamic&gt; json) =&gt; ToDo(
        userId: json["userId"],
        id: json["id"],
        title: json["title"],
        completed: json["completed"],
    );

Map&lt;String, dynamic&gt; toJson() =&gt; {
        "userId": userId,
        "id": id,
        "title": title,
        "completed": completed,
    };
}</code></pre>
<p>and create the model src/models/todo.dart and add the following:</p>
<pre><code>import 'dart:convert';

import 'package:http/http.dart' as http;
import 'package:shared_dart/src/classes/todo.dart' as t;

class TodosModel {
  final kTodosUrl = '[https://jsonplaceholder.typicode.com/todos'](https://jsonplaceholder.typicode.com/todos');

Future&lt;List&lt;t.ToDo&gt;&gt; getList() async {
    final _response = await http.get(kTodosUrl);
    if (_response != null) {
      final _todos = t.toDoFromJson(_response.body);
      if (_todos != null) {
        return _todos;
      }
    }
    return [];
  }

Future&lt;t.ToDo&gt; getItem(int id) async {
    final _response = await http.get('$kTodosUrl/$id');
    if (_response != null) {
      final _todo = t.ToDo.fromJson(json.decode(_response.body));
      if (_todo != null) {
        return _todo;
      }
    }
    return null;
  }
}</code></pre>
<p>Here we just get dummy data from a url that emits json and convert them to our classes. This is an example I want to show with networking. There is only one place that fetches the data.</p>
<h4 id="run-the-project-web">Run the Project (Web)</h4>
<p><img src="https://cdn-images-1.medium.com/max/5248/1*et2kG6_skauXJ6rogFy_ZQ.png" alt="" /></p>
<p><img src="https://cdn-images-1.medium.com/max/5248/1*za20ru3G18DUFob07Cjv2A.png" alt="" /></p>
<p>As you can see when you run your project on chrome you will get the same application that you got on mobile. Even the networking is working in the web. You can call the model and retrieve the list just like you would expect.</p>
<h3 id="server-setup">Server Setup</h3>
<blockquote>
  <p>Now time for the magic..</p>
</blockquote>
<p>In the root of the project folder create a file Dockerfile and add the following:</p>
<pre><code># Use Google's official Dart image.
# [https://hub.docker.com/r/google/dart-runtime/](https://hub.docker.com/r/google/dart-runtime/)
FROM google/dart-runtime</code></pre>
<p>Create another file at the root called service.yaml and add the following:</p>
<pre><code>apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: PROJECT_NAME
  namespace: default
spec:
  template:
    spec:
      containers:
        - image: docker.io/YOUR_DOCKER_NAME/PROJECT_NAME
          env:
            - name: TARGET
              value: "PROJECT_NAME v1"</code></pre>
<p>Replace PROJECT_NAME with your project name, mine is shared-dart for this example.</p>
<p>You will also need to replace YOUR_DOCKER_NAME with your docker username so the container can be deployed correctly.</p>
<p>Update your pubspec.yaml with the following:</p>
<pre><code>name: shared_dart
description: A new Flutter project.
publish_to: none
version: 1.0.0+1

environment:
  sdk: "&gt;=2.1.0 &lt;3.0.0"

dependencies:
  flutter:
    sdk: flutter
  shelf: ^0.7.3
  cupertino_icons: ^0.1.2
  http: ^0.12.0+2

dev_dependencies:
  flutter_test:
    sdk: flutter

flutter:
  uses-material-design: true</code></pre>
<p>The important package here is shelf as it allows us to run a http server with dart.</p>
<p>Create a folder in the root of the project called bin then add a file server.dart and replace it with the following:</p>
<pre><code>import 'dart:io';

import 'package:shelf/shelf.dart' as shelf;
import 'package:shelf/shelf_io.dart' as io;

import 'src/routing.dart';

void main() {
  final handler = const shelf.Pipeline()
      .addMiddleware(shelf.logRequests())
      .addHandler(RouteUtils.handler);

final port = int.tryParse(Platform.environment['PORT'] ?? '8080');
  final address = InternetAddress.anyIPv4;

io.serve(handler, address, port).then((server) {
    server.autoCompress = true;
    print('Serving at [http://${server.address.host}:${server.port}'](http://${server.address.host}:${server.port}'));
  });
}</code></pre>
<p>This will tell the container what port to listen for and how to handle the requests.</p>
<p>Create a folder src in the bin folder and add a file routing.dart and replace the contents with the following:</p>
<pre><code>import 'dart:async';

import 'package:shelf/shelf.dart' as shelf;

import 'controllers/index.dart';
import 'result.dart';

class RouteUtils {
  static FutureOr&lt;shelf.Response&gt; handler(shelf.Request request) {
    var component = request.url.pathSegments.first;
    var handler = _handlers(request)[component];
    if (handler == null) return shelf.Response.notFound(null);
    return handler;
  }

static Map&lt;String, FutureOr&lt;shelf.Response&gt;&gt; _handlers(
      shelf.Request request) {
    return {
      'info': ServerResponse('Info', body: {
        "version": 'v1.0.0',
        "status": "ok",
      }).ok(),
      'counter': CounterController().result(request),
      'todos': TodoController().result(request),
    };
  }
}</code></pre>
<p>There is still nothing imported from our main project but you will start to see some similarities. Here we specify controllers for todos and counter url paths.</p>
<pre><code>'counter': CounterController().result(request),
'todos': TodoController().result(request),</code></pre>
<p>that means any url with the following:<a href="https://mydomain.com/todos" rel="noopener noreferrer" target="_blank">https://mydomain.com/todos</a> , <a href="https://mydomain.com/todos" rel="noopener noreferrer" target="_blank">https://mydomain.com/todos</a>/1</p>
<p>will get routed to the TodoController to handle the request.</p>
<blockquote>
  <p>This is also the first time I found out about FutureOr. It allows you to return a sync or async function.</p>
</blockquote>
<p>And important part about build a REST API is having a consistent response body, so here we can create a wrapper that adds fields we always want to return, like the status of the call, a message and the body.</p>
<p>Create a file at src/result.dart and add the following:</p>
<pre><code>import 'dart:convert';

import 'package:shelf/shelf.dart' as shelf;

class ServerResponse {
  final String message;
  final dynamic body;
  final StatusType type;

ServerResponse(
    this.message, {
    this.type = StatusType.success,
    this.body,
  });

Map&lt;String, dynamic&gt; toJson() {
    return {
      "status": type.toString().replaceAll('StatusType.', ''),
      "message": message,
      "body": body ?? '',
    };
  }

String toJsonString() {
    return json.encode(toJson());
  }

shelf.Response ok() {
    return shelf.Response.ok(
      toJsonString(),
      headers: {
        'Content-Type': 'application/json',
      },
    );
  }
}

enum StatusType { success, error }

abstract class ResponseImpl {
  Future&lt;shelf.Response&gt; result(shelf.Request request);
}</code></pre>
<p>This will always return json and the fields that we want to show. You could also include your paging meta data here.</p>
<p>Create a file in at the location src/controllers/counter.dart and add the following:</p>
<pre><code>import 'package:shared_dart/src/models/counter.dart';
import 'package:shelf/shelf.dart' as shelf;

import '../result.dart';

class CounterController implements ResponseImpl {
  const CounterController();

[@override](http://twitter.com/override)
  Future&lt;shelf.Response&gt; result(shelf.Request request) async {
    final _model = CounterModel();
    final _params = request.url.queryParameters;
    if (_params != null) {
      final _val = int.tryParse(_params['count'] ?? '0');
      _model.set(_val);
    } else {
      _model.add();
    }
    return ServerResponse('Info', body: {
      "counter": _model.count,
    }).ok();
  }
}</code></pre>
<p>You will see the import to the lib folder of the root project. Since it shares the pubspec.yaml all the packages can be shared. You can import the CounterModel that we created earlier.</p>
<p>Create a file in at the location src/controllers/todos.dart and add the following:</p>
<pre><code>import 'package:shared_dart/src/models/todos.dart';
import 'package:shelf/src/request.dart';

import 'package:shelf/src/response.dart';

import '../result.dart';

class TodoController implements ResponseImpl {
  [@override](http://twitter.com/override)
  Future&lt;Response&gt; result(Request request) async {
    final _model = TodosModel();
    if (request.url.pathSegments.length &gt; 1) {
      final _id = int.tryParse(request.url.pathSegments[1] ?? '1');
      final _todo = await _model.getItem(_id);
      return ServerResponse('Todo Item', body: _todo).ok();
    }
    final _todos = await _model.getList();
    return ServerResponse(
      'List Todos',
      body: _todos.map((t) =&gt; t.toJson()).toList(),
    ).ok();
  }
}</code></pre>
<p>Just like before we are importing the TodosModel model from the lib folder.</p>
<p>For convenience add a file at the location src/controllers/index.dart and add the following:</p>
<pre><code>export 'counter.dart';
export 'todo.dart';</code></pre>
<p>This will make it easier to import all the controllers.</p>
<h3 id="run-the-project-server">Run the Project (Server)</h3>
<p>If you are using <a href="https://code.visualstudio.com/" rel="noopener noreferrer" target="_blank">VSCode</a> then you will need to update your launch.json with the following:</p>
<pre><code>{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: [https://go.microsoft.com/fwlink/?linkid=830387](https://go.microsoft.com/fwlink/?linkid=830387)
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Client",
            "request": "launch",
            "type": "dart",
            "program": "lib/main.dart"
        }, 
         {
            "name": "Server",
            "request": "launch",
            "type": "dart",
            "program": "bin/server.dart"
        }
    ]
}</code></pre>
<p>Now when you hit run with Server selected you will see the output:</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*akfcrkLuxit4vZdtHJty_Q.png" alt="" /></p>
<p>You can navigate to this in a browser but you can also work with this in <a href="https://www.getpostman.com/" rel="noopener noreferrer" target="_blank">Postman</a>.</p>
<p><img src="https://cdn-images-1.medium.com/max/4796/1*zJR2ZNZfCmvLg3y5wByLNA.png" alt="" /></p>
<p><img src="https://cdn-images-1.medium.com/max/4788/1*Z2vnHjHEfYe8yWajGWVLOw.png" alt="" /></p>
<p>Just by adding to the url todos and todos/1 it will return different responses.</p>
<p>For the counter model we can use query parameters too!</p>
<p><img src="https://cdn-images-1.medium.com/max/4768/1*YMwQEOoaCjngYpidKBbADg.png" alt="" /></p>
<p><img src="https://cdn-images-1.medium.com/max/4760/1*vPYs9780bcVrlIPBMjF4eQ.png" alt="" /></p>
<p>Just by adding ?count=22 it will update the model with the input.</p>
<blockquote>
  <p>Keep in mind this is running your Dart code from you lib folder in your Flutter project without needing the Flutter widgets!</p>
</blockquote>
<p>As a side benefit we can also run this project on Desktop. Check out the final project for the desktop folders needed from <a href="https://github.com/google/flutter-desktop-embedding" rel="noopener noreferrer" target="_blank">Flutter Desktop Embedding</a>.</p>
<p><img src="https://cdn-images-1.medium.com/max/3648/1*Mk_6Rlq2qMbpk79OPo_QBw.png" alt="" /></p>
<p><img src="https://cdn-images-1.medium.com/max/3648/1*hWirIWGRQjN8hVvUZsB2Nw.png" alt="" /></p>
<h3 id="conclusion">Conclusion</h3>
<p>Now if you wanted to deploy the container to Cloud Run you could with the following command:</p>
<p>gcloud builds submit — tag gcr.io/YOUR_GOOGLE_PROJECT_ID/PROJECT_NAME .</p>
<p>Replace PROJECT_NAME with your project name, mine is shared-dart for this example.</p>
<p>You will also need to replace YOUR_GOOGLE_PROJECT_ID with your Google Cloud Project ID. You can create one <a href="https://cloud.google.com/cloud-build/docs/quickstart-docker" rel="noopener noreferrer" target="_blank">here</a>.</p>
<p>Again the final project source code is <a href="https://github.com/AppleEducate/shared_dart" rel="noopener noreferrer" target="_blank">here</a>. Let me know your thoughts!</p>
        </article>
      </nav-wrapper>
      <noscript>You need to enable JavaScript to run this app.</noscript>
      <script type="module" src="/dist/components/nav-wrapper.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>
  
  <script
    src="https://utteranc.es/client.js"
    repo="rodydavis/rodydavis"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async
  ></script>
  
    <script src="https://www.gstatic.com/firebasejs/8.2.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.2.1/firebase-analytics.js"></script>
    <script>
      // window.addEventListener('load', () => {
      //   navigator.serviceWorker.register('/sw.js');
      // });

      const firebaseConfig = {
        apiKey: 'AIzaSyCfbxrJWY2QgbSJrCnS3jZ8mfBwvQrqII0',
        authDomain: 'development-267918.firebaseapp.com',
        databaseURL: 'https://development-267918.firebaseio.com',
        projectId: 'development-267918',
        storageBucket: 'development-267918.appspot.com',
        messagingSenderId: '700791912456',
        appId: '1:700791912456:web:0b4947c995cec6c38bb9bd',
        measurementId: 'G-JQNPVBL9DR',
      };
      firebase.initializeApp(firebaseConfig);
      firebase.analytics();
    </script>
    
    </body>
  </html>